#!/usr/bin/env bash

volume=50
music_dir="../nfc-jukebox-resources/songs"

pause_tag="0012310413"
shutdown_tag="0011566376"

volume_up_tag="0012228406"
volume_down_tag="0012201985"

seek_forward="0012014364"
seek_backward="0011908459"

next="0011574660"
previous="0011753580"

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
hooks_file="$script_dir""/nfc-jukebox-hooks"
[[ -n "$1" ]] && hooks_file="$1"

control_pipe="/tmp/nfc-jukebox-pipe"
log_file="/tmp/nfc-jukebox-logfile.log"
mplayer_process="mplayer -slave"

# shellcheck source=jukebox-hooks
source "${hooks_file}"

# Get absolute path of directory
music_dir=$(readlink -f $music_dir)

if [[ ! -d "$music_dir" ]]; then
  echo "Not a valid music directory: '$music_dir'"
  exit 1
fi

# Is used to kill mplayer
#
# $1 - Process name
kill_process() {
  pids=$(pgrep -f "$1")
  if [[ -n "$pids" ]]; then
    for pid in $pids; do
      if [[ "$pid" != "$$" ]]; then
        echo "Stopping process: $pid"
        disown "$pid" >/dev/null 2>&1
        kill -9 "$pid"
      fi
    done
  fi
}

# Cleanup
teardown() {
  echo && hook "shutdown"
  kill_process "$mplayer_process"
}

# We want to cleanup, if the script gets killed.
trap teardown EXIT

# Executes user hooks
#
# $1    - Hook name
# $2-$* - Hook arguments
hook() {
  hook_name="$1"
  shift
  if [[ "$(type -t "$hook_name")" == "function" ]]; then
    eval "$hook_name $*"
  fi
}

create_control_pipe() {
  [[ -p "$control_pipe" ]] && rm "$control_pipe"
  mkfifo "$control_pipe"
}

stop_playback() {
  pids=$(pgrep -f "mplayer -slave")
  if [[ -n "$pids" ]]; then
    echo "quit" >"$control_pipe" &
    sleep 0.1
    kill_process "$mplayer_process"
  fi
}

echo && hook "startup"

start_playback() {
  stop_playback
  create_control_pipe

  file="$1"
  filename=$(basename -- "$file")
  extension="${filename##*.}"

  arguments=(
    "-slave"
    "-shuffle"
    "-volume" "$volume"
    "-msglevel" "all=4"
    "-loop" "0"
    "-input" "file=$control_pipe"
  )

  if [[ "$extension" == "txt" ]]; then
    # get random line from the file
    file="$(shuf -n 1 "$file")"
  fi

  if [[ "$file" == *.m3u ]]; then
    arguments=("${arguments[@]}" "-playlist" "$file")
  elif [[ -d "$file" ]]; then
    arguments=("${arguments[@]}" "$file/"*)
  else
    arguments=("${arguments[@]}" "$file")
  fi

  nohup mplayer "${arguments[@]/#/}" &>>"$log_file" &
}

get_timestamp() {
  date +%s%N | cut -b1-13
}

set_volume() {
  volume=$((volume + $1))

  if [[ "$volume" -gt 100 ]]; then
    volume=100
  fi

  if [[ "$volume" -lt 10 ]]; then
    volume=10
  fi

  hook "volume_changed" "$volume"
  echo "volume $volume 1" >"$control_pipe" &
}

while true; do
  read -rep $'Waiting for tag...\n' id

  if [[ -z $start_timestamp ]]; then
    start_timestamp=$(get_timestamp)
  else
    end_timestamp=$(get_timestamp)
    duration=$((end_timestamp - start_timestamp))
    if [[ "$duration" -lt 500 ]]; then
      echo "Temporary locked"
      continue
    fi
    start_timestamp=$(get_timestamp)
  fi

  hook "on_tag" "$id"

  # Searching for the file that starts with given id
  entry=$(find "$music_dir" -name "$id - *")

  if [[ -f "$entry" ]] || [[ -d "$entry" ]]; then
    hook "playing_file" "$(printf '%q\n' "$entry")"
    start_playback "$entry"
    continue
  fi

  if [[ "$id" == "$pause_tag" ]]; then
    hook "pause"
    echo "pause" >"$control_pipe" &
    continue
  fi

  if [[ "$id" == "$seek_forward" ]]; then
    echo "seek_forward 15 0" >"$control_pipe" &
    continue
  fi

  if [[ "$id" == "$seek_backward" ]]; then
    echo "seek_backward 15 0" >"$control_pipe" &
    continue
  fi

  if [[ "$id" == "$volume_up_tag" ]]; then
    set_volume 10
    continue
  fi

  if [[ "$id" == "$volume_down_tag" ]]; then
    set_volume -10
    continue
  fi

  if [[ "$id" == "$next" ]]; then
    echo "pt_step 1" >"$control_pipe" &
    continue
  fi

  if [[ "$id" == "$previous" ]]; then
    echo "pt_step -1" >"$control_pipe" &
    continue
  fi

  if [[ "$id" == "$shutdown_tag" ]]; then
    echo "pause" >"$control_pipe" &
    break
  fi

done